// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.11
// Project name: core135_llm_product

#include "../ui/ui.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <thread>
#include <chrono>
#include <ctime>
#include <iostream>
#include <list>
#include <mutex>
#include <string>
#include <thread>

#include <sys/select.h>
#include <unistd.h>

#include <iostream>
#include <cstring>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <opencv2/opencv.hpp>
// #include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgcodecs.hpp>

extern pthread_mutex_t ui_thread_mutex;
extern int ax_llm_connect_flage;

#define ui_lock() pthread_mutex_lock(&ui_thread_mutex)

#define ui_unlock() pthread_mutex_unlock(&ui_thread_mutex)


lv_obj_t ** ui_page;
lv_obj_t * *map_page_obj[] = {&ui_EMMC,  &ui_SDTEST,  &ui_OTGTEST,  &ui_I2CTEST,  &ui_CHARGE,
                               &ui_CAMTEST,  &ui_CMMTEST,  &ui_WIFITEST,  &ui_CAPPLAY, &ui_LOCADTEST, &ui_LLMTEST};
lv_obj_t * *map_btn_obj[] = {&ui_Button1,  &ui_Button3,  &ui_Button4,  &ui_Button5,  &ui_Button7,
                                &ui_Button8,  &ui_Button9,  &ui_Button10,  &ui_Button11, &ui_Button12, &ui_Button26};



static int charge_flage = 0;


extern "C"{
    void pravite_my_init();
};
int ax_llm_connect_flage = 0;

void ui_event_TextArea(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t *ta         = lv_event_get_target(e);

    if (code == LV_EVENT_VALUE_CHANGED) {
        const char *text = lv_textarea_get_text(ta);
        size_t len       = strlen(text);
        if (len > 1024*4) {
            char truncated_text[1024*3];
            memcpy(truncated_text, text + (len - 1024*3), 1024*3);
            lv_textarea_set_text(ta, truncated_text);
        }
    }
}

#include <stdio.h>
#include <string.h>
#include <time.h>
struct cpu_use_t {
    long double a[4];
    long time;
};
char *get_times()
{
    static char time_buff[16];
    time_t now           = time(NULL);
    struct tm *tm_struct = localtime(&now);
    strftime(time_buff, 9, "%H:%M:%S", tm_struct);
    return time_buff;
}
void get_memory_info(unsigned long *total_memory, unsigned long *free_memory)
{
    FILE *meminfo = fopen("/proc/meminfo", "r");
    if (meminfo == NULL) {
        perror("fopen");
        return;
    }
    char line[256];
    while (fgets(line, sizeof(line), meminfo)) {
        if (strncmp(line, "MemTotal:", 9) == 0) {
            sscanf(line, "MemTotal: %lu kB", total_memory);
        }
        if (strncmp(line, "MemAvailable:", 13) == 0) {
            sscanf(line, "MemAvailable: %lu kB", free_memory);
            break;  // Exit the loop when available memory information is found.
        }
    }
    fclose(meminfo);
}
typedef struct ifconfig_s {
    char name[128];
    char ip[16];
    char mask[16];
    char broadcast[16];
    char mac[20];
} ifconfig_t;
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <linux/if.h>
#include <arpa/inet.h>
#include <vector>
#include <string>
int ifconfig(std::vector<ifconfig_t>& ifcs) {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        return -10;
    }

    struct ifconf ifc;
    char buf[1024];
    ifc.ifc_len = sizeof(buf);
    ifc.ifc_buf = buf;

    int iRet = ioctl(sock, SIOCGIFCONF, &ifc);
    if (iRet != 0) {
        close(sock);
        return iRet;
    }

    int cnt = ifc.ifc_len / sizeof(struct ifreq);
    //printf("ifc.size=%d\n", cnt);
    if (cnt == 0) {
        close(sock);
        return -20;
    }

    struct ifreq ifr;
    ifcs.clear();
    ifconfig_t tmp;
    for (int i = 0; i < cnt; ++i) {
        // name
        strcpy(ifr.ifr_name, ifc.ifc_req[i].ifr_name);
        //printf("name: %s\n", ifr.ifr_name);
        strncpy(tmp.name, ifr.ifr_name, sizeof(tmp.name));
        // flags
        //iRet = ioctl(sock, SIOCGIFFLAGS, &ifr);
        //short flags = ifr.ifr_flags;
        // addr
        iRet = ioctl(sock, SIOCGIFADDR, &ifr);
        struct sockaddr_in* addr = (struct sockaddr_in*)&ifr.ifr_addr;
        char* ip = inet_ntoa(addr->sin_addr);
        //printf("ip: %s\n", ip);
        strncpy(tmp.ip, ip, sizeof(tmp.ip));
        // netmask
        iRet = ioctl(sock, SIOCGIFNETMASK, &ifr);
        addr = (struct sockaddr_in*)&ifr.ifr_netmask;
        char* netmask = inet_ntoa(addr->sin_addr);
        //printf("netmask: %s\n", netmask);
        strncpy(tmp.mask, netmask, sizeof(tmp.mask));
        // broadaddr
        iRet = ioctl(sock, SIOCGIFBRDADDR, &ifr);
        addr = (struct sockaddr_in*)&ifr.ifr_broadaddr;
        char* broadaddr = inet_ntoa(addr->sin_addr);
        //printf("broadaddr: %s\n", broadaddr);
        strncpy(tmp.broadcast, broadaddr, sizeof(tmp.broadcast));
        // hwaddr
        iRet = ioctl(sock, SIOCGIFHWADDR, &ifr);
        snprintf(tmp.mac, sizeof(tmp.mac), "%02x:%02x:%02x:%02x:%02x:%02x",
            (unsigned char)ifr.ifr_hwaddr.sa_data[0],
            (unsigned char)ifr.ifr_hwaddr.sa_data[1],
            (unsigned char)ifr.ifr_hwaddr.sa_data[2],
            (unsigned char)ifr.ifr_hwaddr.sa_data[3],
            (unsigned char)ifr.ifr_hwaddr.sa_data[4],
            (unsigned char)ifr.ifr_hwaddr.sa_data[5]);
        //printf("mac: %s\n", tmp.mac);
        //printf("\n");

        if (strcmp(tmp.ip, "0.0.0.0") == 0 ||
            strcmp(tmp.ip, "127.0.0.1") == 0 ||
            strcmp(tmp.mac, "00:00:00:00:00:00") == 0) {
            continue;
        }

        ifcs.push_back(tmp);
    }

    close(sock);
    return 0;
}

void lvgl_task_get_system_cb(lv_timer_t *tmr)
{
    char cpu_str[16];
    char mem_str[16];
    unsigned long one;
    unsigned long two;
    static struct cpu_use_t laster = {0};
    struct cpu_use_t now;
    long double loadavg;

    FILE *fp = fopen("/proc/stat", "r");
    fscanf(fp, "%*s %Lf %Lf %Lf %Lf", &now.a[0], &now.a[1], &now.a[2], &now.a[3]);
    fclose(fp);
    now.time = LV_TICK_CUSTOM_SYS_TIME_EXPR;
    if (laster.time != 0) {
        loadavg =
            ((now.a[0] + now.a[1] + now.a[2]) - (laster.a[0] + laster.a[1] + laster.a[2])) /
            ((now.a[0] + now.a[1] + now.a[2] + now.a[3]) - (laster.a[0] + laster.a[1] + laster.a[2] + laster.a[3]));
        sprintf(cpu_str, "%d%%", (int)(loadavg * 100));
        lv_label_set_text(ui_Label24, cpu_str);
        memcpy(&laster, &now, sizeof(struct cpu_use_t));
        get_memory_info(&one, &two);
        float use = ((one * 1.0f) - (two * 1.0f)) / (one * 1.0f);
        sprintf(mem_str, "%d%%", (int)(use * 100));
        lv_label_set_text(ui_Label25, mem_str);
    } else {
        memcpy(&laster, &now, sizeof(struct cpu_use_t));
    }
    lv_label_set_text(ui_Label33, get_times());
    
    char eth_ip_buff_str[256] = {0};
    std::vector<ifconfig_t> ifcs;
    ifconfig(ifcs);
    for (auto &item : ifcs) {
        // nlohmann::json eth_info;
        // eth_info["name"]      = item.name;
        // eth_info["ip"]        = item.ip;
        char eth_ip_buff[128] = {0};
        sprintf(eth_ip_buff, "/sys/class/net/%s/speed", item.name);
        FILE *file = fopen(eth_ip_buff, "r");
        memset(eth_ip_buff, 0, sizeof(eth_ip_buff));
        if (file != NULL) {
            int size = fread(eth_ip_buff, 1, sizeof(eth_ip_buff), file);
            if (size > 0) eth_ip_buff[size - 1] = '\0';
            fclose(file);
        }
        if(std::string(item.name) == "eth0"){
            sprintf(eth_ip_buff_str, "%s: %s Mbps", item.ip, eth_ip_buff);
        }
    }
    if (strlen(eth_ip_buff_str)!=0)
    {
        lv_label_set_text(ui_Label27, eth_ip_buff_str);

        if(strstr(eth_ip_buff_str, "1000") != NULL)
        {
            lv_obj_set_style_bg_color(ui_Panel6, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
        }
        else
        {
            lv_obj_set_style_bg_color(ui_Panel6, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }
    else
    {
        lv_label_set_text(ui_Label27, "disclinet");
        lv_obj_set_style_bg_color(ui_Panel6, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    }


    unsigned long temp;
    fp = fopen("/sys/class/thermal/thermal_zone0/temp", "r");
    fscanf(fp, "%Li", &temp);
    fclose(fp);
    sprintf(eth_ip_buff_str, "%d C", temp / 1000);
    lv_label_set_text(ui_Label26, eth_ip_buff_str);

    if (*ui_page == *map_page_obj[4]) {
        std::string lines;
        const char *command = "echo Voltage:$(i2cget -y -f 1 0x55 0x08 w);echo Status:$(i2cget -y -f 1 0x55 0x0A w);";
        FILE *pipe          = popen(command, "r");
        if (pipe == NULL) {
            perror("popen failed");
            goto charge_batty_e;
        }
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            lines += std::string(buffer);
        }
        pclose(pipe);

        if (lines.length() > 27) {
            int Voltage = std::stoi(lines.substr(lines.find("Voltage:") + 8, 6), nullptr, 16);
            int Status = std::stoi(lines.substr(lines.find("Status:") + 7, 6), nullptr, 16);
            sprintf(buffer, "%d mV", Voltage);
            lv_label_set_text(ui_Label49, buffer);
            if(Status & 0b1)
            {
                sprintf(buffer, "Discharge");
                lv_label_set_text(ui_Label51, buffer);
            }
            else{
                sprintf(buffer, "Charge");
                lv_label_set_text(ui_Label51, buffer);
            }
        } else {
            sprintf(buffer, "no select batty!");
            lv_label_set_text(ui_Label49, buffer);
            lv_label_set_text(ui_Label51, buffer);
        }
    }
charge_batty_e: {
}
}
// // void lvgl_task_led_color_cb(lv_timer_t *tmr) {
// //     static int i;
// //     i += 70;
// // }

// // void add_hidden_flage() {
// //     lv_obj_add_flag(ui_Chart1, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Chart8, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Chart7, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Chart3, LV_OBJ_FLAG_HIDDEN);

// //     lv_obj_add_flag(ui_Chart4, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Chart5, LV_OBJ_FLAG_HIDDEN);

// //     // lv_obj_add_flag(ui_TabPage1, LV_OBJ_FLAG_HIDDEN);
// //     // lv_obj_add_flag(ui_TabPage2, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_TabPage6, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_TabPage7, LV_OBJ_FLAG_HIDDEN);

// //     lv_obj_clear_flag(ui_Image4, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Image5, LV_OBJ_FLAG_HIDDEN);
// //     // lv_obj_add_flag(ui_TabPage5, LV_OBJ_FLAG_HIDDEN);     /// Flags

// //     lv_obj_add_flag(ui_Panel4, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Panel9, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Label8, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Label9, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Label10, LV_OBJ_FLAG_HIDDEN);
// //     lv_obj_add_flag(ui_Label25, LV_OBJ_FLAG_HIDDEN);

// //     lv_obj_add_flag(ui_TextArea10, LV_OBJ_FLAG_HIDDEN);

// //     // lv_obj_add_event_cb(ui_Colorwheel3, ui_event_Colorwheel3, LV_EVENT_ALL, NULL);
// //     // lv_obj_add_event_cb(ui_Slider3, ui_event_Slider3, LV_EVENT_ALL, NULL);
// //     // lv_obj_add_event_cb(ui_Panel5, ui_event_Panel5, LV_EVENT_ALL, NULL);
// //     // lv_obj_add_event_cb(ui_Button5, ui_event_Button5, LV_EVENT_ALL, NULL);
// //     // lv_obj_add_event_cb(ui_TabView3, ui_event_TabView3, LV_EVENT_ALL, NULL);

// //     lv_obj_add_event_cb(ui_TextArea2, ui_event_TextArea, LV_EVENT_ALL, NULL);
// //     lv_obj_add_event_cb(ui_TextArea8, ui_event_TextArea, LV_EVENT_ALL, NULL);
// //     lv_obj_add_event_cb(ui_TextArea6, ui_event_TextArea, LV_EVENT_ALL, NULL);
// //     lv_obj_add_event_cb(ui_TextArea4, ui_event_TextArea, LV_EVENT_ALL, NULL);
// //     lv_obj_add_event_cb(ui_TextArea3, ui_event_TextArea, LV_EVENT_ALL, NULL);
// //     lv_obj_add_event_cb(ui_TextArea5, ui_event_TextArea, LV_EVENT_ALL, NULL);

// //     lv_obj_add_flag(ui_Slider2, LV_OBJ_FLAG_HIDDEN);
// //     // lv_obj_add_state(ui_Slider2, LV_STATE_DISABLED);
// // }

// // void cpp_init();
// // void pravite_my_init() {

// //     ui_Label11111 = lv_label_create(ui_TabPage8);
// //     lv_obj_set_width(ui_Label11111, LV_SIZE_CONTENT);   /// 1
// //     lv_obj_set_height(ui_Label11111, LV_SIZE_CONTENT);    /// 1
// //     lv_obj_set_x(ui_Label11111, 40);
// //     lv_obj_set_y(ui_Label11111, 37);
// //     lv_obj_set_align(ui_Label11111, LV_ALIGN_CENTER);
// //     lv_label_set_text(ui_Label11111, "eth0 not connect!");

// //     add_hidden_flage();
// //     lv_timer_create(lvgl_task_get_system_cb, 1000, NULL);
// //     lv_timer_create(lvgl_task_led_color_cb, 70, NULL);
// //     cpp_init();
// // }
// const void *map_index_obj[] = {&ui_Panel1,  &ui_Panel2,  &ui_Panel3,  &ui_Panel5,  &ui_Panel6,
//                                &ui_Panel7,  &ui_Panel8,  &ui_Panel9,  &ui_Panel10, &ui_Panel11,
//                                &ui_Panel12, &ui_Panel13, &ui_Panel14, &ui_Panel15};
// void start_hw_info();
// void stop_hw_info();
// void kit_led_switch_call(lv_event_t *e)
// {
//     int len            = lv_tabview_get_tab_act(ui_TabView1);
//     static int old_len = 0;
//     if (len == old_len) {
//         return;
//     }
//     old_len = len;

//     for (size_t i = 0; i < sizeof(map_index_obj) / sizeof(map_index_obj[0]); i++) {
//         if (len == i)
//             lv_obj_set_style_bg_color(*((lv_obj_t **)map_index_obj[i]), lv_color_hex(0x0300F6),
//                                       LV_PART_MAIN | LV_STATE_DEFAULT);
//         else
//             lv_obj_set_style_bg_color(*((lv_obj_t **)map_index_obj[i]), lv_color_hex(0x7DA4DC),
//                                       LV_PART_MAIN | LV_STATE_DEFAULT);
//     }
//     lv_tabview_t *tabview = (lv_tabview_t *)ui_TabView1;
//     if (strcmp("LOAD", (const char *)tabview->map[len]) == 0) {
//         start_hw_info();
//     } else {
//         stop_hw_info();
//     }
// }




void lock_switch()
{
    for (size_t i = 0; i < sizeof(map_btn_obj) / sizeof(map_btn_obj[0]); i++)
    {
        lv_obj_add_state(* map_btn_obj[i], LV_STATE_DISABLED);
    }
}
void unlock_switch()
{
    for (size_t i = 0; i < sizeof(map_btn_obj) / sizeof(map_btn_obj[0]); i++)
    {
        lv_obj_clear_state(* map_btn_obj[i], LV_STATE_DISABLED);
    }
}




void pravite_my_init()
{
    ui_page = &ui_EMMC;
    lv_timer_create(lvgl_task_get_system_cb, 1000, NULL);
    lv_obj_add_event_cb(ui_TextArea1, ui_event_TextArea, LV_EVENT_ALL, NULL);



    for(size_t i = 0; i < sizeof(map_page_obj) / sizeof(map_page_obj[0]); i++)
    {
        lv_obj_add_flag(*map_page_obj[i], LV_OBJ_FLAG_HIDDEN);
    }
    lv_obj_clear_flag(*ui_page, LV_OBJ_FLAG_HIDDEN);
    lv_obj_set_style_bg_color(*map_btn_obj[0], lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_obj_add_event_cb(ui_TextArea3, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea4, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea5, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea9, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea10, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea11, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea6, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea7, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // lv_obj_add_event_cb(ui_TextArea8, ui_event_TextArea, LV_EVENT_ALL, NULL);
    // printf("");
    // lv_tabview_class
}
#include <functional>
void str_parse_line(const std::string &da, std::string &lines,
                    std::function<void(const std::string &)> call_fun)
{
    for (auto c : da) {
        if (c != '\n') {
                    lines += c;
        } else {
            lines += "\n";
            call_fun(lines);
            lines.clear();
        }
    }
}

void ax_cmmc_test_task() {
    // int ret;
    lv_obj_t ** ui_Button = &ui_Button13;
    lv_obj_t ** ui_TextArea = &ui_TextArea1;
    lv_obj_t ** ui_Chart = &ui_Chart1;

    lv_obj_t ** R_ui_Label = &ui_Label23;
    lv_obj_t ** W_ui_Label = &ui_Label21;

    std::string lines;
    lv_chart_series_t *ui_Chart1_series_1;
    lv_chart_series_t *ui_Chart1_series_2;
    lv_coord_t *ui_Chart1_series_1_array;
    lv_coord_t *ui_Chart1_series_2_array;
    float Ravg_s       = 0.0;
    float Wavg_s       = 0.0;
    int arrar_count[2] = {0};
    int summ[2]        = {0};
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "test llm emmc.\n");
    // lv_chart_set_range(ui_Chart1, LV_CHART_AXIS_SECONDARY_Y, 0, 200);
    ui_Chart1_series_1       = lv_chart_get_series_next(*ui_Chart, NULL);
    ui_Chart1_series_2       = lv_chart_get_series_next(*ui_Chart, ui_Chart1_series_1);
    ui_Chart1_series_1_array = lv_chart_get_y_array(*ui_Chart, ui_Chart1_series_1);
    ui_Chart1_series_2_array = lv_chart_get_y_array(*ui_Chart, ui_Chart1_series_2);
    memset(ui_Chart1_series_1_array, 0, sizeof(lv_coord_t) * 10);
    memset(ui_Chart1_series_2_array, 0, sizeof(lv_coord_t) * 10);
    lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_1, ui_Chart1_series_1_array);
    lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_2, ui_Chart1_series_2_array);
    ui_unlock();



    int success_count = 0;
    {
        int request_id_num = -1;
        const char *command = 
            "mkdir -p /root/fsiotest ; "
            "cd /root/fsiotest ; "
            "sysbench fileio --file-total-size=512M prepare ; "
            "sysbench fileio --file-total-size=512M --file-test-mode=seqrd --report-interval=1 --max-time=11 "
            "--file-extra-flags=direct run ; "
            "sysbench fileio --file-total-size=512M --file-test-mode=seqwr --report-interval=1 --max-time=11 "
            "--file-extra-flags=direct run ; "
            "sysbench fileio --file-total-size=512M cleanup ; "
            "cd /root ; rm /root/fsiotest -rf ; "
            "sync ; ";
            FILE *pipe = popen(command, "r");
            if (pipe == NULL) {
                perror("popen failed");
                goto cmmc_task_e;
            }
            char buffer[128];
            while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
                str_parse_line(std::string(buffer), lines, [&](const std::string &_lin) {
                    // ui_lock();
                    // lv_textarea_add_text(*ui_TextArea, _lin.c_str());
                    // ui_unlock();
                    if (_lin.find("Creating") != std::string::npos) {
                        ui_lock();
                        lv_textarea_add_text(*ui_TextArea, ".");
                        ui_unlock();
                    }
                    if (_lin.find("latency") != std::string::npos) {
                        ui_lock();
                        lv_textarea_add_text(*ui_TextArea, _lin.c_str());
                        ui_unlock();

                        int find_index;
                        double writes, reads;
                        std::string writess, readss;
                        find_index = _lin.find("reads: ");
                        if (find_index != std::string::npos) {
                            for (size_t i = find_index + 7; i < _lin.length(); i++) {
                                // printf("%c",_lin[i]);
                                if (_lin[i] != ' ') {
                                    readss += _lin[i];
                                } else {
                                    break;
                                }
                            }
                            // printf("readss:%s<\n", readss.c_str());
                            reads = std::stod(readss);
                        }
                        find_index = _lin.find("writes: ");
                        if (find_index != std::string::npos) {
                            for (size_t i = find_index + 8; i < _lin.length(); i++) {
                                // printf("%c",_lin[i]);
                                if (_lin[i] != ' ') {
                                    writess += _lin[i];
                                } else {
                                    break;
                                }
                            }
                            // printf("writess:%s<\n", readss.c_str());
                            writes = std::stod(writess);
                        }
                        ui_lock();

                        // printf("get writes:%f reads:%f\n", writes, reads);
                        if (reads > 0) {
                            if (arrar_count[0] < 10) {
                                ui_Chart1_series_1_array[arrar_count[0]++] = (int)reads;
                                summ[0] += (int)reads;
                                Ravg_s = (float)summ[0] / (float)arrar_count[0];
                            }
                            std::string lab_tmp = std::to_string((int)Ravg_s) + "M/s";
                            lv_label_set_text(*R_ui_Label, lab_tmp.c_str());
                            lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_1, ui_Chart1_series_1_array);
                            {
                                lv_coord_t min_value = 1000;
                                lv_coord_t max_value = 0;
                                for (uint32_t i = 0; i < 10; i++) {
                                    if (ui_Chart1_series_1_array[i] < min_value)
                                        min_value = ui_Chart1_series_1_array[i];
                                    if (ui_Chart1_series_1_array[i] > max_value)
                                        max_value = ui_Chart1_series_1_array[i];
                                }
                                min_value = min_value > 25 ? min_value - 25 : 0;
                                max_value += 25;
                                lv_chart_set_range(*ui_Chart, LV_CHART_AXIS_SECONDARY_Y, min_value, max_value);
                                // lv_chart_refresh(ui_Chart1);
                            }
                        }
                        if (writes > 0) {
                            if (arrar_count[1] < 10) {
                                ui_Chart1_series_2_array[arrar_count[1]++] = (int)writes;
                                summ[1] += (int)writes;
                                Wavg_s = (float)summ[1] / (float)arrar_count[1];
                            }
                            std::string lab_tmp = std::to_string((int)Wavg_s) + "M/s";
                            lv_label_set_text(*W_ui_Label, lab_tmp.c_str());
                            lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_2, ui_Chart1_series_2_array);
                            {
                                lv_coord_t min_value = 1000;
                                lv_coord_t max_value = 0;
                                for (int i = 0; i < 10; i++) {
                                    if (ui_Chart1_series_2_array[i] < min_value)
                                        min_value = ui_Chart1_series_2_array[i];
                                    if (ui_Chart1_series_2_array[i] > max_value)
                                        max_value = ui_Chart1_series_2_array[i];
                                }
                                min_value = min_value > 15 ? min_value - 15 : 0;
                                max_value += 15;
                                lv_chart_set_range(*ui_Chart, LV_CHART_AXIS_PRIMARY_Y, min_value, max_value);
                                // lv_chart_refresh(ui_Chart1);
                            }
                        }
                        // if (lv_obj_has_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN))
                        //     lv_obj_clear_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN);
                        // if (!lv_obj_has_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN))
                        //     lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN);
                        ui_unlock();
                    }
                });
            }
            pclose(pipe);
    }

cmmc_task_e:
    int error = 0;
    // for (size_t i = 0; i < 10; i++)
    // {
    //     if(ui_Chart1_series_1_array[i] < 80)
    //     {
    //         error = 1;
    //         break;
    //     }
    //     if(ui_Chart1_series_2_array[i] < 70)
    //     {
    //         error = 1;
    //         break;
    //     }
    // }
    if (Ravg_s < 80) {
        error = 1;
    }
    if (Wavg_s < 60) {
        error = 1;
    }
    if (error) {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "emmc test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    } else {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "emmc test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    }

    ui_lock();
    unlock_switch();
    lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);

    ui_unlock();
}

void ax_sd_test_task() {
    // int ret;
    lv_obj_t ** ui_Button = &ui_Button14;
    lv_obj_t ** ui_TextArea = &ui_TextArea3;
    lv_obj_t ** ui_Chart = &ui_Chart3;

    lv_obj_t ** R_ui_Label = &ui_Label32;
    lv_obj_t ** W_ui_Label = &ui_Label30;

    std::string lines;
    lv_chart_series_t *ui_Chart1_series_1;
    lv_chart_series_t *ui_Chart1_series_2;
    lv_coord_t *ui_Chart1_series_1_array;
    lv_coord_t *ui_Chart1_series_2_array;
    float Ravg_s       = 0.0;
    float Wavg_s       = 0.0;
    int arrar_count[2] = {0};
    int summ[2]        = {0};
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "test llm emmc.\n");
    // lv_chart_set_range(ui_Chart1, LV_CHART_AXIS_SECONDARY_Y, 0, 200);
    ui_Chart1_series_1       = lv_chart_get_series_next(*ui_Chart, NULL);
    ui_Chart1_series_2       = lv_chart_get_series_next(*ui_Chart, ui_Chart1_series_1);
    ui_Chart1_series_1_array = lv_chart_get_y_array(*ui_Chart, ui_Chart1_series_1);
    ui_Chart1_series_2_array = lv_chart_get_y_array(*ui_Chart, ui_Chart1_series_2);
    memset(ui_Chart1_series_1_array, 0, sizeof(lv_coord_t) * 10);
    memset(ui_Chart1_series_2_array, 0, sizeof(lv_coord_t) * 10);
    lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_1, ui_Chart1_series_1_array);
    lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_2, ui_Chart1_series_2_array);
    ui_unlock();



    int success_count = 0;
    {
        int request_id_num = -1;
        const char *command = 
            "[ -d /mnt/mmcblk1p2/fsiotest ] || { echo \\\"mmcblk1p2_not_exists\\\" ; exit 1 ; } ; "
            "cd /mnt/mmcblk1p2/fsiotest ; "
            "sysbench fileio --file-total-size=512M prepare ; "
            "sysbench fileio --file-total-size=512M --file-test-mode=seqrd --report-interval=1 --max-time=11 "
            "--file-extra-flags=direct run ; "
            "sysbench fileio --file-total-size=512M --file-test-mode=seqwr --report-interval=1 --max-time=11 "
            "--file-extra-flags=direct run ; "
            "sysbench fileio --file-total-size=512M cleanup ; "
            "sync ; ";
            FILE *pipe = popen(command, "r");
            if (pipe == NULL) {
                perror("popen failed");
                goto cmmc_task_e;
            }
            char buffer[128];
            while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
                str_parse_line(std::string(buffer), lines, [&](const std::string &_lin) {
                    // ui_lock();
                    // lv_textarea_add_text(*ui_TextArea, _lin.c_str());
                    // ui_unlock();
                    if (_lin.find("mmcblk1p2_not_exists") != std::string::npos) {
                        ui_lock();
                        lv_textarea_add_text(* ui_TextArea, "mmcblk1p2 not exists!\n");
                        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
                        ui_unlock();
                    }
                    if (_lin.find("Creating") != std::string::npos) {
                        ui_lock();
                        lv_textarea_add_text(*ui_TextArea, ".");
                        ui_unlock();
                    }
                    if (_lin.find("latency") != std::string::npos) {
                        ui_lock();
                        lv_textarea_add_text(*ui_TextArea, _lin.c_str());
                        ui_unlock();

                        int find_index;
                        double writes, reads;
                        std::string writess, readss;
                        find_index = _lin.find("reads: ");
                        if (find_index != std::string::npos) {
                            for (size_t i = find_index + 7; i < _lin.length(); i++) {
                                // printf("%c",_lin[i]);
                                if (_lin[i] != ' ') {
                                    readss += _lin[i];
                                } else {
                                    break;
                                }
                            }
                            // printf("readss:%s<\n", readss.c_str());
                            reads = std::stod(readss);
                        }
                        find_index = _lin.find("writes: ");
                        if (find_index != std::string::npos) {
                            for (size_t i = find_index + 8; i < _lin.length(); i++) {
                                // printf("%c",_lin[i]);
                                if (_lin[i] != ' ') {
                                    writess += _lin[i];
                                } else {
                                    break;
                                }
                            }
                            // printf("writess:%s<\n", readss.c_str());
                            writes = std::stod(writess);
                        }
                        ui_lock();

                        // printf("get writes:%f reads:%f\n", writes, reads);
                        if (reads > 0) {
                            if (arrar_count[0] < 10) {
                                ui_Chart1_series_1_array[arrar_count[0]++] = (int)reads;
                                summ[0] += (int)reads;
                                Ravg_s = (float)summ[0] / (float)arrar_count[0];
                            }
                            std::string lab_tmp = std::to_string((int)Ravg_s) + "M/s";
                            lv_label_set_text(*R_ui_Label, lab_tmp.c_str());
                            lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_1, ui_Chart1_series_1_array);
                            {
                                lv_coord_t min_value = 1000;
                                lv_coord_t max_value = 0;
                                for (uint32_t i = 0; i < 10; i++) {
                                    if (ui_Chart1_series_1_array[i] < min_value)
                                        min_value = ui_Chart1_series_1_array[i];
                                    if (ui_Chart1_series_1_array[i] > max_value)
                                        max_value = ui_Chart1_series_1_array[i];
                                }
                                min_value = min_value > 25 ? min_value - 25 : 0;
                                max_value += 25;
                                lv_chart_set_range(*ui_Chart, LV_CHART_AXIS_SECONDARY_Y, min_value, max_value);
                                // lv_chart_refresh(ui_Chart1);
                            }
                        }
                        if (writes > 0) {
                            if (arrar_count[1] < 10) {
                                ui_Chart1_series_2_array[arrar_count[1]++] = (int)writes;
                                summ[1] += (int)writes;
                                Wavg_s = (float)summ[1] / (float)arrar_count[1];
                            }
                            std::string lab_tmp = std::to_string((int)Wavg_s) + "M/s";
                            lv_label_set_text(*W_ui_Label, lab_tmp.c_str());
                            lv_chart_set_ext_y_array(*ui_Chart, ui_Chart1_series_2, ui_Chart1_series_2_array);
                            {
                                lv_coord_t min_value = 1000;
                                lv_coord_t max_value = 0;
                                for (int i = 0; i < 10; i++) {
                                    if (ui_Chart1_series_2_array[i] < min_value)
                                        min_value = ui_Chart1_series_2_array[i];
                                    if (ui_Chart1_series_2_array[i] > max_value)
                                        max_value = ui_Chart1_series_2_array[i];
                                }
                                min_value = min_value > 15 ? min_value - 15 : 0;
                                max_value += 15;
                                lv_chart_set_range(*ui_Chart, LV_CHART_AXIS_PRIMARY_Y, min_value, max_value);
                                // lv_chart_refresh(ui_Chart1);
                            }
                        }
                        // if (lv_obj_has_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN))
                        //     lv_obj_clear_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN);
                        // if (!lv_obj_has_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN))
                        //     lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN);
                        ui_unlock();
                    }
                });
            }
            pclose(pipe);
    }

cmmc_task_e:
    int error = 0;
    // for (size_t i = 0; i < 10; i++)
    // {
    //     if(ui_Chart1_series_1_array[i] < 80)
    //     {
    //         error = 1;
    //         break;
    //     }
    //     if(ui_Chart1_series_2_array[i] < 70)
    //     {
    //         error = 1;
    //         break;
    //     }
    // }
    if (Ravg_s < 30) {
        error = 1;
    }
    if (Wavg_s < 7) {
        error = 1;
    }
    if (error) {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "emmc test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    } else {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "emmc test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    }

    ui_lock();
    unlock_switch();
    lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);

    ui_unlock();
}

void ax_i2c_test_task()
{
    lv_obj_t ** ui_Button = &ui_Button16;
    lv_obj_t ** ui_Button1 = &ui_Button25;
    lv_obj_t ** ui_TextArea = &ui_TextArea7;
    // lv_obj_t ** ui_Chart = &ui_Chart3;

    int error = 0;
    int ret;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(* ui_TextArea, "test llm i2c.\n");
    ui_unlock();
    {

        {
            int request_id_num = -1;
            const char *command = 
                "i2cget -y -f 1 0x68 0x00 ; [ \"$?\" != \"0\" ] && echo \"BMI270 ERROR\" ; "
                "i2cget -y -f 1 0x55 0x08 w ; [ \"$?\" != \"0\" ] && echo \"POWER IC ERROR\" ; "
                "i2cget -y -f 1 0x57 0x00 ; [ \"$?\" != \"0\" ] && echo \"Unit Heart ERROR\" ; "
                "i2cget -y -f 1 0x29 0x00 ; [ \"$?\" != \"0\" ] && echo \"Unit TOF ERROR\" ; "    
                "i2cget -y 1 0x55 0x00 ; [ \"$?\" != \"0\" ] && echo \"Batty ERROR\" ; "
            ;
                FILE *pipe = popen(command, "r");
                if (pipe == NULL) {
                    perror("popen failed");
                    goto sd_task_e;
                }
                char buffer[128];
                while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
                    str_parse_line(std::string(buffer), lines, [&](const std::string &_lin) {
                        ui_lock();
                        lv_textarea_add_text(* ui_TextArea, _lin.c_str());
                        ui_unlock();
                        if(_lin.find("ERROR") != std::string::npos)
                        {
                            error = 1;
                        }
                    });
                }
                pclose(pipe);
        }
    }
    sd_task_e:
    if (error) {
        ui_lock();
        lv_textarea_add_text(* ui_TextArea, "i2c test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    } else {
        ui_lock();
        lv_textarea_add_text(* ui_TextArea, "i2c test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    }
    ui_lock();
    unlock_switch();
    lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_clear_state(*ui_Button1, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}

#include <math.h>
#define Kp      10.0f                        // proportional gain governs rate of convergence to accelerometer/magnetometer
#define Ki      0.008f                       // integral gain governs rate of convergence of gyroscope biases
#define halfT   0.001f                   // half the sample period,sapmple freq=500Hz
 
static float q0 = 1, q1 = 0, q2 = 0, q3 = 0;    // quaternion elements representing the estimated orientation
static float exInt = 0, eyInt = 0, ezInt = 0;    // scaled integral error
 
static float yaw = 0;
static float pitch = 0;
static float roll = 0;
 
void IMU_Update(float gx, float gy, float gz, float ax, float ay, float az)
{
    float norm;
    float vx, vy, vz;
    float ex, ey, ez;
    float temp0, temp1, temp2, temp3; 
 
    float q0q0 = q0 * q0;
    float q0q1 = q0 * q1;
    float q0q2 = q0 * q2;
    //float q0q3 = q0 * q3;
    float q1q1 = q1 * q1;
    //float q1q2 = q1 * q2;
    float q1q3 = q1 * q3;
    float q2q2 = q2 * q2;
    float q2q3 = q2 * q3;
    float q3q3 = q3 * q3;
 
    if (ax * ay * az == 0)
    {
        return;
    }
 
    norm = sqrt(ax * ax + ay * ay + az * az);       //
    ax = ax / norm;
    ay = ay / norm;
    az = az / norm;
 
    // estimated direction of gravity and flux (v and w)
    vx = 2 * (q1q3 - q0q2);
    vy = 2 * (q0q1 + q2q3);
    vz = q0q0 - q1q1 - q2q2 + q3q3 ;
 
    // error is sum of cross product between reference direction of fields and direction measured by sensors
    ex = (ay * vz - az * vy) ;
    ey = (az * vx - ax * vz) ;
    ez = (ax * vy - ay * vx) ;
 
    exInt = exInt + ex * Ki;
    eyInt = eyInt + ey * Ki;
    ezInt = ezInt + ez * Ki;
 
    // adjusted gyroscope measurements
    gx = gx + Kp * ex + exInt;
    gy = gy + Kp * ey + eyInt;
    gz = gz + Kp * ez + ezInt;
 
    // integrate quaternion rate and normalise
    temp0 = q0;
    temp1 = q1;
    temp2 = q2;
    temp3 = q3;
    q0 += (-temp1 * gx - temp2 * gy - temp3 * gz) * halfT;
    q1 += (temp0 * gx + temp2 * gz - temp3 * gy) * halfT;
    q2 += (temp0 * gy - temp1 * gz + temp3 * gx) * halfT;
    q3 += (temp0 * gz + temp1 * gy - temp2 * gx) * halfT;
 
    // normalise quaternion
    norm = sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
    q0 = q0 / norm;
    q1 = q1 / norm;
    q2 = q2 / norm;
    q3 = q3 / norm;
 
    yaw = atan2(2 * q1 * q2 + 2 * q0 * q3, -2 * q2 * q2 - 2 * q3 * q3 + 1) * 57.3; // unit:degree
    pitch = asin(-2 * q1 * q3 + 2 * q0 * q2) * 57.3; // unit:degree
    roll = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2 * q2 + 1) * 57.3; // unit:degree
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#define IIO_PATH "/sys/bus/iio/devices/iio:device1"  // 替换为实际设备路径

// 函数：读取文件中的值
int read_sensor_value(const char *file_path, char *buffer, size_t buffer_size) {
    int fd = open(file_path, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open file");
        return -1;
    }

    ssize_t bytes_read = read(fd, buffer, buffer_size - 1);
    if (bytes_read < 0) {
        perror("Failed to read file");
        close(fd);
        return -1;
    }

    buffer[bytes_read - 1] = '\0';  // 确保缓冲区以 NULL 结尾
    close(fd);
    return 0;
}


void ax_bmi270_test_task()
{
    lv_obj_t ** ui_Button = &ui_Button25;
    lv_obj_t ** ui_Button1 = &ui_Button16;
    lv_obj_t ** ui_TextArea = &ui_TextArea7;
    // lv_obj_t ** ui_Chart = &ui_Chart3;

    int error = 0;
    int ret;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(* ui_TextArea, "test llm i2c.\n");
    ui_unlock();
    {
        char accel_x_path[256];
        char accel_y_path[256];
        char accel_z_path[256];
        char gyro_x_path[256];
        char gyro_y_path[256];
        char gyro_z_path[256];
    
        char bufferx[64];
        char buffery[64];
        char bufferz[64];
        char gyro_bufferx[64];
        char gyro_buffery[64];
        char gyro_bufferz[64];
    
        // 构造加速度计路径
        snprintf(accel_x_path, sizeof(accel_x_path), "%s/in_accel_x_raw", IIO_PATH);
        snprintf(accel_y_path, sizeof(accel_y_path), "%s/in_accel_y_raw", IIO_PATH);
        snprintf(accel_z_path, sizeof(accel_z_path), "%s/in_accel_z_raw", IIO_PATH);
    
        // 构造陀螺仪路径
        snprintf(gyro_x_path, sizeof(gyro_x_path), "%s/in_anglvel_x_raw", IIO_PATH);
        snprintf(gyro_y_path, sizeof(gyro_y_path), "%s/in_anglvel_y_raw", IIO_PATH);
        snprintf(gyro_z_path, sizeof(gyro_z_path), "%s/in_anglvel_z_raw", IIO_PATH);
        int cout = 0;
        while (charge_flage)
        {
            ret = 0;
            // 读取加速度计值
            ret += read_sensor_value(accel_x_path, bufferx, sizeof(bufferx));
            ret += read_sensor_value(accel_y_path, buffery, sizeof(buffery));
            ret += read_sensor_value(accel_z_path, bufferz, sizeof(bufferz));
            // 读取陀螺仪值
            ret += read_sensor_value(gyro_x_path, gyro_bufferx, sizeof(gyro_bufferx));
            ret += read_sensor_value(gyro_y_path, gyro_buffery, sizeof(gyro_buffery));
            ret += read_sensor_value(gyro_z_path, gyro_bufferz, sizeof(gyro_bufferz));
            if(ret != 0)
            {
                continue;
            }
            // 解析读取到的值
            int accel_x = atoi(bufferx);
            int accel_y = atoi(buffery);
            int accel_z = atoi(bufferz);
            int gyro_x = atoi(gyro_bufferx);
            int gyro_y = atoi(gyro_buffery);
            int gyro_z = atoi(gyro_bufferz);

            // 乘以相关系数
            float faccel_x = accel_x * 0.000598f;
            float faccel_y = accel_y * 0.000598f;
            float faccel_z = accel_z * 0.000598f;
            float fgyro_x = gyro_x * 0.000532f;
            float fgyro_y = gyro_y * 0.000532f;
            float fgyro_z = gyro_z * 0.000532f;
            IMU_Update(fgyro_x, fgyro_y, fgyro_z, faccel_x, faccel_y, faccel_z);
            if(cout++ % 50 == 0)
            {
                ui_lock();
                lv_obj_set_y(ui_Panel4, (int)pitch);
                lv_obj_set_x(ui_Panel4, (int)(roll>0? -roll+180 : -roll - 180));
                ui_unlock();
            }
        }
    }
    sd_task_e:
    if (error) {
        ui_lock();
        lv_textarea_add_text(* ui_TextArea, "i2c test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    } else {
        ui_lock();
        lv_textarea_add_text(* ui_TextArea, "i2c test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    }
    ui_lock();
    unlock_switch();
    // lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_clear_state(*ui_Button1, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}
























void ax_charge_test_task()
{
    lv_obj_t **ui_Button   = &ui_Button17;
    lv_obj_t **ui_TextArea = &ui_TextArea6;
    int ret;
    std::string lines;

    {
        const char *commanda = 
            "i2cset -y -f -m 0x80 1 0x49 0x02 0x80;"
            "i2cset -y -f -m 0x07 1 0x49 0x01 0x04;"
            "i2cset -y -f -m 0xC0 1 0x49 0x01 0x40;"
            "i2cset -y -f -m 0xF0 1 0x49 0x03 0x90;"
            "i2cset -y -f -m 0x0F 1 0x49 0x00 0x0F;"
            "i2cset -y -f -m 0xF0 1 0x49 0x00 0x60;"
            "i2cset -y -f -m 0x0F 1 0x49 0x07 0x08;"
            "i2cset -y -f -m 0xFC 1 0x49 0x04 0xA0;"
            "i2cset -y -f -m 0x02 1 0x49 0x04 0x02;"
            "i2cset -y -f -m 0x01 1 0x49 0x04 0x01;"
            "i2cset -y -f -m 0x80 1 0x49 0x0B 0x00;"
            "i2cset -y -f -m 0x3F 1 0x49 0x02 0x38;"
            "i2cset -y -f -m 0x0F 1 0x49 0x03 0x0F;"
            "i2cset -y -f -m 0x30 1 0x49 0x07 0x30;"
            "i2cset -y -f -m 0x60 1 0x49 0x05 0x00;"
            "i2cset -y -f -m 0x80 1 0x49 0x06 0x00;"
            "i2cset -y -f -m 0x80 1 0x49 0x07 0x80;"
            "i2cset -y -f -m 0x08 1 0x49 0x01 0x00;"
        ;
        system(commanda);
    }
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "charging ...\n");
    ui_unlock();
    int charge_test_success = 1;
    while (charge_flage) {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        const char *command = "echo StatusRegister:$(i2cget -y -f 1 0x49 0x08);"
                                "echo FaultRegister:$(i2cget -y -f 1 0x49 0x09);";
        FILE *pipe = popen(command, "r");
        if (pipe == NULL) {
            perror("popen failed");
            goto charge_task_e;
        }
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            lines += std::string(buffer);
        }
        pclose(pipe);

        int StatusRegister = std::stoi(lines.substr(lines.find("StatusRegister:") + 15, 4), nullptr, 16);
        int FaultRegister  = std::stoi(lines.substr(lines.find("FaultRegister:") + 14, 4), nullptr, 16);

        std::string errormsg;
        if ((StatusRegister & 0b10) != 0b10) errormsg += "Power false! ";
        if (FaultRegister & 0b1) errormsg += "NTC cold! ";
        if (FaultRegister & 0b10) errormsg += "NTC hot! ";
        if (FaultRegister & 0b100) errormsg += "safety timer expiration! ";
        if (FaultRegister & 0b1000) errormsg += "battery OVP! ";
        if (FaultRegister & 0b10000) errormsg += "thermal shutdown! ";
        if (FaultRegister & 0b100000) errormsg += "input fault (OVP or bad source)! ";
        if (!errormsg.empty()) {
            charge_test_success = 0;
        }
        if ((StatusRegister & 0b11000) == 0b11000)
            errormsg += "Charge done! ";
        else if ((StatusRegister & 0b11000) == 0b10000)
            errormsg += "Charging! ";
        else if ((StatusRegister & 0b11000) == 0b01000)
            errormsg += "Pre Charge! ";
        else if ((StatusRegister & 0b11000) == 0b00000)
            errormsg += "NO Charge! ";
        errormsg += "\n";
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, errormsg.c_str());
        ui_unlock();
        lines.clear();
    }
    system("i2cset -y -f -m 0x08 1 0x49 0x01 0x08;");
charge_task_e:
    if (!charge_test_success) {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "\n discharge\n");
        unlock_switch();
        lv_textarea_add_text(*ui_TextArea, "charge test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    } else {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "\n discharge\n");
        unlock_switch();
        lv_textarea_add_text(*ui_TextArea, "charge test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    }
}


void ax_cmm_test_task()
{
    lv_obj_t ** ui_Button = &ui_Button19;
    lv_obj_t ** ui_TextArea = &ui_TextArea10;
    // int ret;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(* ui_TextArea, "test llm cmm.\n");
    ui_unlock();
    int success_count = 0;
    {
        const char *command = "/usr/local/m5stack/bin/sample_cmm ";
        FILE *pipe = popen(command, "r");
        if (pipe == NULL) {
            perror("popen failed");
            goto cmm_task_e;
        }
        setvbuf(pipe, NULL, _IOFBF, 1024 * 1024);
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            str_parse_line(std::string(buffer), lines, [&](const std::string &_lin) {
                
                if (_lin.find("ax_mem_cmm_test_") != std::string::npos) {
                    if (_lin.find("end success") != std::string::npos) {
                        success_count++;
                    } else {
                        if (_lin.find("end.Total:3, Pass:3,") != std::string::npos) {
                            success_count++;
                        }
                    }
                    ui_lock();
                    lv_textarea_add_text(* ui_TextArea, _lin.c_str());
                    ui_unlock();
                }
                
            });
        }
        pclose(pipe);
    }
cmm_task_e:

    ui_lock();
    if (success_count < 17) {
        lv_textarea_add_text(* ui_TextArea, "cmm test false!\n");
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_textarea_add_text(* ui_TextArea, "cmm test success!\n");
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    lv_textarea_add_text(* ui_TextArea, "ax_llm cmm over!\n");
    unlock_switch();
    lv_obj_clear_state(* ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}



std::vector<std::string> split_string(const std::string& content, const std::string& delimiter)
{
    std::vector<std::string> result;
    std::string::size_type pos1 = 0;
    std::string::size_type pos2 = content.find(delimiter);
    while (std::string::npos != pos2) {
        result.push_back(content.substr(pos1, pos2 - pos1));
        pos1 = pos2 + delimiter.size();
        pos2 = content.find(delimiter, pos1);
    }
    if (pos1 != content.length()) {
        result.push_back(content.substr(pos1));
    }
    return result;
}

void ax_wifi_test_task()
{
    lv_obj_t ** ui_Button = &ui_Button20;
    lv_obj_t ** ui_TextArea = &ui_TextArea9;
    // int ret;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(* ui_TextArea, "test llm cmm.\n");
    ui_unlock();
    int success_count = -1000;
    {
        const char *command = 
            "if ! grep -q \"esp32_sdio\" /proc/modules ; "
            "then "
            "/usr/local/m5stack/bin/S03espc6wifi start ; "
            "sleep 5 ; "
            "fi ; "
            "wpa_cli -i wlan0 scan && wpa_cli -i wlan0 scan_result ; ";
        FILE *pipe = popen(command, "r");
        if (pipe == NULL) {
            perror("popen failed");
            goto cmm_task_e;
        }
        setvbuf(pipe, NULL, _IOFBF, 1024 * 1024);
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            str_parse_line(std::string(buffer), lines, [&](const std::string &_lin) {
                std::vector<std::string> duanstr = split_string(_lin, "\t");
                if(duanstr.size() > 3)
                {
                    int mk = std::stoi(duanstr[2]);
                    if (mk > success_count) success_count = mk;
                }
                ui_lock();
                lv_textarea_add_text(* ui_TextArea, _lin.c_str());
                ui_unlock();
            });
        }
        pclose(pipe);
    }
cmm_task_e:
    printf("success_count:%d\n", success_count);
    ui_lock();
    if (success_count < -25) {
        lv_textarea_add_text(* ui_TextArea, "wifi test false!\n");
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_textarea_add_text(* ui_TextArea, "wifi test success!\n");
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    lv_textarea_add_text(* ui_TextArea, "ax_llm wifi over!\n");
    unlock_switch();
    lv_obj_clear_state(* ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}
int cap_flage = 0;
void ax_cap_test_task()
{
    lv_obj_t **ui_Button1   = &ui_Button21;
    lv_obj_t **ui_Button2   = &ui_Button22;
    lv_obj_t **ui_Button3   = &ui_Button23;
    lv_obj_t **ui_TextArea = &ui_TextArea11;
    int ret;
    std::string lines;
    system(". /etc/profile ; start-stop-daemon --start --quiet --background --pidfile /tmp/.sample_audio_cap.pid --make-pidfile --exec /opt/bin/sample_audio -- ai -D 0 -d 0 -w 1 --layout 1 -o /tmp/cap_audio.wav");
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "caping ...\n");
    ui_unlock();
    int timewait = 0;
    while (cap_flage) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if(timewait ++ % 5)
        {
            ui_lock();
            lv_textarea_add_text(*ui_TextArea, ".");
            ui_unlock();
        }
    }
    system("start-stop-daemon --stop --signal INT --pidfile /tmp/.sample_audio_cap.pid ");
charge_task_e:
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "\n cap done\n");
    // lv_obj_clear_state(* ui_Button1, LV_STATE_DISABLED);
    lv_obj_clear_state(* ui_Button2, LV_STATE_DISABLED);
    lv_obj_clear_state(* ui_Button3, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_set_style_bg_color(* ui_Button1, lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
    unlock_switch();
    ui_unlock();
}

void ax_play_cap_test_task()
{
    lv_obj_t **ui_Button1   = &ui_Button21;
    lv_obj_t **ui_Button2   = &ui_Button22;
    lv_obj_t **ui_Button3   = &ui_Button23;
    lv_obj_t **ui_TextArea = &ui_TextArea11;
    // int ret;
    std::string lines;

    if(access("/tmp/cap_audio.wav", F_OK) == 0)
    {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "play cap audio...\n");
        ui_unlock();
        system(". /etc/profile ; sample_audio ao -D 0 -d 1 -i /tmp/cap_audio.wav");
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "\n play cap done\n");
        ui_unlock();
    }
    else
    {
        ui_lock();
        lv_textarea_add_text(*ui_TextArea, "no cap file!\n");
        lv_obj_set_style_bg_color(* ui_Button2, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
        ui_unlock();
    }

    ui_lock();
    lv_obj_clear_state(* ui_Button1, LV_STATE_DISABLED);
    // lv_obj_clear_state(* ui_Button2, LV_STATE_DISABLED);
    lv_obj_clear_state(* ui_Button3, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);


    lv_obj_set_style_bg_color(* ui_Button2, lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
    
    unlock_switch();
    ui_unlock();
}

void ax_play_test_test_task()
{
    lv_obj_t **ui_Button1   = &ui_Button21;
    lv_obj_t **ui_Button2   = &ui_Button22;
    lv_obj_t **ui_Button3   = &ui_Button23;
    lv_obj_t **ui_TextArea = &ui_TextArea11;
    // int ret;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "play logo audio...\n");
    ui_unlock();
    system(". /etc/profile ; tinyplay -D0 -d1 /usr/local/m5stack/logo.wav");
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "\n play logo done\n");
    lv_obj_clear_state(* ui_Button1, LV_STATE_DISABLED);
    lv_obj_clear_state(* ui_Button2, LV_STATE_DISABLED);
    // lv_obj_clear_state(* ui_Button3, LV_STATE_DISABLED);
    lv_obj_add_flag(* ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_set_style_bg_color(* ui_Button3, lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
    unlock_switch();
    ui_unlock();
}

// "[ -d \\\"/sys/class/gpio/gpio511\\\" ] || { echo 511 > /sys/class/gpio/export ; echo out > /sys/class/gpio/gpio511/direction ; } ; "
// "echo \\\"if [[ \\\\$(( \\\\$(i2cget -y -f 1 0x43 0x0f) & 0x8 )) -eq 8 ]]; then echo 255 > /sys/class/leds/sys_led/brightness ; else echo 0 > /sys/class/leds/sys_led/brightness ; fi \\\" > /tmp/sys_led_blak.sh ; "
// "start-stop-daemon --start --quiet --background --make-pidfile --pidfile /var/run/test_io_demo.pid  "
// "--exec /bin/bash -- -c \\\""
// "i2cset -y -f 1 0x43 0x0D 0x8 ; "
// "while true ; do "
//     "echo 0  > /sys/class/gpio/gpio511/value ; "
//     "bash /tmp/sys_led_blak.sh ; "
//     "sleep 0.5; "
//     "echo 1  > /sys/class/gpio/gpio511/value ; "
//     "bash /tmp/sys_led_blak.sh ; "
//     "sleep 0.5 ; "
// "done \\\" ; ",
#include "linux_uart/linux_uart.h"
void ax_otg_test_task()
{
    lv_obj_t **ui_Button    = &ui_Button15;
    lv_obj_t **ui_TextArea  = &ui_TextArea4;
    lv_obj_t **ui_TextArea1 = &ui_TextArea5;
    int ret;
    int test_success = 0;

    std::string lines;
    system(
        "[ -d \"/sys/class/gpio/gpio511\" ] || { echo 511 > /sys/class/gpio/export ; echo out > "
        "/sys/class/gpio/gpio511/direction ; } ;"
        "echo 0  > /sys/class/gpio/gpio511/value ;");
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "open /dev/ttyACM0 \n");
    ui_unlock();
    int timewait = 0;
    int uart1;
    while (charge_flage) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if (access("/dev/ttyACM0", F_OK) == 0) {
            uart_t uart_parm = {.baud = 115200, .data_bits = 8, .stop_bits = 1, .parity = 'n'};
            uart1            = linux_uart_init("/dev/ttyACM0", &uart_parm);
            if (uart1 < 0) {
                ui_lock();
                lv_textarea_add_text(*ui_TextArea, "open /dev/ttyACM0 failed \n");
                ui_unlock();
                continue;
            } else {
                ui_lock();
                lv_textarea_add_text(*ui_TextArea, "open /dev/ttyACM0 success \n");
                ui_unlock();
                while (charge_flage) {
                    const char *pingmsg = "}";
                    linux_uart_write(uart1, 1, (uint8_t *)pingmsg);
                    struct timeval timeout = {.tv_sec = 1, .tv_usec = 0};
                    fd_set set;
                    FD_ZERO(&set);
                    FD_SET(uart1, &set);
                    int ret = select(uart1 + 1, &set, NULL, NULL, &timeout);
                    if (ret == 1) {
                        char buf[1024] = {0};
                        int len        = linux_uart_read(uart1, sizeof(buf), (uint8_t *)buf);
                        if (len > 0) {
                            ui_lock();
                            lv_textarea_add_text(*ui_TextArea, buf);
                            ui_unlock();
                        }
                        if (std::string(buf).find("reace reset")!=std::string::npos)
                        {
                            test_success = 1;
                        }
                    }
                    else
                    {
                        printf("un read \n");
                    }
                    std::this_thread::sleep_for(std::chrono::milliseconds(500));
                }
            }
        }
    }
    if(uart1 > 0)
    {
        linux_uart_deinit(uart1);
    }
    system("echo 1  > /sys/class/gpio/gpio511/value ");
otg_task_e:

    ui_lock();
    if (test_success == 0) {
        lv_textarea_add_text(*ui_TextArea, "otg test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_textarea_add_text(*ui_TextArea, "otg test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    lv_textarea_add_text(*ui_TextArea, "ax_llm otg over!\n");
    unlock_switch();
    lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}
std::string sample_json_str_get(const std::string &json_str, const std::string &json_key)
{
    std::string key_val;
    std::string format_val;
    // SLOGD("json_str: %s json_key:%s\n", json_str.c_str(), json_key.c_str());
    std::string find_key = "\"" + json_key + "\"";
    int subs_start       = json_str.find(find_key);
    if (subs_start == std::string::npos) {
        return key_val;
    }
    key_val.reserve(json_str.length());
    int status    = 0;
    char last_c   = '\0';
    int obj_flage = 0;
    for (auto c : json_str.substr(subs_start + find_key.length())) {
        switch (status) {
            case 0: {
                switch (c) {
                    case '"': {
                        status = 100;
                    } break;
                    case '{': {
                        key_val.push_back(c);
                        obj_flage = 1;
                        status    = 10;
                    } break;
                    case ':':
                        obj_flage = 1;
                        break;
                    case ',':
                    case '}': {
                        obj_flage = 0;
                        status    = -1;
                    } break;
                    case ' ':
                        break;
                    default: {
                        if (obj_flage) {
                            key_val.push_back(c);
                        }
                    } break;
                }
            } break;
            case 10: {
                key_val.push_back(c);
                if (c == '{') {
                    obj_flage++;
                }
                if (c == '}') {
                    obj_flage--;
                }
                if (obj_flage == 0) {
                    if (!key_val.empty()) {
                        status = -1;
                    }
                }
            } break;
            case 100: {
                if ((c == '"') && (last_c != '\\')) {
                    obj_flage = 0;
                    status    = -1;
                } else {
                    key_val.push_back(c);
                }
            } break;
            default:
                break;
        }
        last_c = c;
    }
    if (obj_flage != 0) {
        key_val.clear();
    }
    // SLOGD("key_val:%s\n", key_val.c_str());
    return key_val;
}
#define BASE64_ENCODE_OUT_SIZE(s) (((s) + 2) / 3 * 4)
#define BASE64_DECODE_OUT_SIZE(s) (((s)) / 4 * 3)
#include <stdio.h>
/* BASE 64 encode table */
static const char base64en[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

#define BASE64_PAD     '='
#define BASE64DE_FIRST '+'
#define BASE64DE_LAST  'z'
/* ASCII order for BASE 64 decode, -1 in unused character */
static const signed char base64de[] = {
    62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0,  1,  2,  3,  4,
    5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1,
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
};
static int base64_decode(const char *in, unsigned int inlen, unsigned char *out)
{
    unsigned int i = 0, j = 0;
    for (; i < inlen; i++) {
        int c;
        int s = i % 4;
        if (in[i] == '=') return j;
        if (in[i] < BASE64DE_FIRST || in[i] > BASE64DE_LAST || (c = base64de[in[i] - BASE64DE_FIRST]) == -1) return -1;
        switch (s) {
            case 0:
                out[j] = ((unsigned int)c << 2) & 0xFF;
                continue;
            case 1:
                out[j++] += ((unsigned int)c >> 4) & 0x3;
                /* if not last char with padding */
                if (i < (inlen - 3) || in[inlen - 2] != '=') out[j] = ((unsigned int)c & 0xF) << 4;
                continue;
            case 2:
                out[j++] += ((unsigned int)c >> 2) & 0xF;
                /* if not last char with padding */
                if (i < (inlen - 2) || in[inlen - 1] != '=') out[j] = ((unsigned int)c & 0x3) << 6;
                continue;
            case 3:
                out[j++] += (unsigned char)c;
        }
    }
    return j;
}
int decode_base64(const std::string &in, std::string &out)
{
    int out_size = BASE64_DECODE_OUT_SIZE(in.length());
    out.resize(out_size);
    int ret = base64_decode((const char *)in.c_str(), in.length(), (unsigned char *)out.data());
    if ((ret > 0) && (ret != out_size)) out.erase(ret);
    return ret;
}

lv_img_dsc_t my_image = {0};
cv::Mat display_frame;
void ax_cam_test_task()
{
    lv_obj_t ** ui_Button = &ui_Button18;
    lv_obj_t ** ui_TextArea = &ui_TextArea8;
    lv_obj_t ** ui_image = &ui_Image2;
    my_image.header.always_zero = 0;
    my_image.header.w = 320;
    my_image.header.h = 320;
    my_image.data_size = 320 * 320 * sizeof(lv_color_t);
    my_image.header.cf = LV_IMG_CF_TRUE_COLOR_ALPHA;
    my_image.data = NULL;
    int ret;
    int test_success = 0;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "open axera_single_sc850sl \n");
    lv_obj_clear_flag(*ui_image, LV_OBJ_FLAG_HIDDEN);
    ui_unlock();
    int timewait = 0;
    int uart1;
    int sock = 0;
    while (charge_flage) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        struct sockaddr_in serv_addr;
        const char *server_ip = "127.0.0.1";  // 服务器IP地址
        const int server_port = 10001;         // 服务器端口
        char buffer[1024] = {0};
    
        // 创建套接字
        if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
            std::cerr << "Socket creation error" << std::endl;
            sock = 0;
            continue;
        }
    
        // 设置服务器地址
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(server_port);
    
        // 将IP地址转换为二进制形式
        if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {
            std::cerr << "Invalid address/ Address not supported" << std::endl;
            close(sock);
            sock = 0;
            continue;
        }
    
        // 连接到服务器
        printf("connect server ...\n");
        if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
            std::cerr << "Connection Failed" << std::endl;
            close(sock);
            sock = 0;
            continue;
        }     
        printf("connect success!\n");   
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        lines = R"({"request_id": "1", "work_id": "camera", "action": "setup", "object": "camera.setup", "data": {"response_format": "image.yuvraw.base64", "input": "axera_single_sc850sl", "enoutput": true, "frame_width": 320, "frame_height": 320}})";
        ssize_t bytes_sent = send(sock, lines.c_str(), lines.size(), 0);
        if (bytes_sent == -1) {
            printf("send failed");
            close(sock);
            sock = 0;
            continue;
        }
        lines.clear();
        printf("send success!\n");  
        int count = 0;
        while (charge_flage)
        {
            struct timeval timeout = {.tv_sec = 10, .tv_usec = 0};
            fd_set set;
            FD_ZERO(&set);
            FD_SET(sock, &set);
            int ret = select(sock + 1, &set, NULL, NULL, &timeout);
            if (ret == 1) {
                int valread = recv(sock, buffer, sizeof(buffer) - 1, 0);
                lines += std::string(buffer, valread);
                // printf("reace:%.*s\n", valread, buffer);
                while (charge_flage)
                {
                    size_t post = std::string::npos;
                    post = lines.find("\n");
                    if(post != std::string::npos)
                    {
                        if(count++ % 10 == 0)
                        {
                            auto one_data = lines.substr(0, post);
                            auto post1 = one_data.find("image.yuvraw.base64");
                            if(post1 != std::string::npos)
                            {
                                auto image_base64 = sample_json_str_get(one_data, "data");
                                std::string image_data;
                                decode_base64(image_base64, image_data);
                                cv::Mat yuv422 = cv::Mat(320, 320, CV_8UC2, (void *)image_data.data());
                                cv::cvtColor(yuv422, display_frame, cv::COLOR_YUV2BGRA_YUYV);
                                ui_lock();
                                my_image.data = (const uint8_t*)display_frame.data;
                                lv_img_set_src(*ui_image, &my_image);
                                ui_unlock();
                                test_success = 1;
                            }
                        }
                        lines.erase(0, post+1);
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                close(sock);
                sock = 0;
                test_success = 0;
                charge_flage = 0;
            }
        }
        
    }
    if(sock > 0)
    {
        {
            close(sock);
            sock = 0;
        }
    }
    system("systemctl restart llm-camera llm-sys");
otg_task_e:

    ui_lock();
    if (test_success == 0) {
        lv_textarea_add_text(*ui_TextArea, "cam test false!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    } else {
        lv_textarea_add_text(*ui_TextArea, "cam test success!\n");
        lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
    }

    lv_textarea_add_text(*ui_TextArea, "ax_llm cam over!\n");
    unlock_switch();
    lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}

int llm_test_sock = 0;
void ax_llm_test_task()
{
    lv_obj_t **ui_Button   = &ui_Button27;
    lv_obj_t **ui_TextArea = &ui_TextArea12;

    int ret;
    int test_success = 0;
    std::string lines;
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "open llm \n");
    ui_unlock();
    int timewait = 0;
    int uart1;
    // while (charge_flage) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    struct sockaddr_in serv_addr;
    const char *server_ip = "127.0.0.1";  // 服务器IP地址
    const int server_port = 10001;        // 服务器端口
    char buffer[1024]     = {0};
    ssize_t bytes_sent;
    // 创建套接字
    if ((llm_test_sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        std::cerr << "Socket creation error" << std::endl;
        llm_test_sock = 0;
        goto llm_error;
    }

    // 设置服务器地址
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port   = htons(server_port);

    // 将IP地址转换为二进制形式
    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {
        std::cerr << "Invalid address/ Address not supported" << std::endl;
        close(llm_test_sock);
        llm_test_sock = 0;
        goto llm_error;
    }
    // 连接到服务器
    printf("connect server ...\n");
    if (connect(llm_test_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        std::cerr << "Connection Failed" << std::endl;
        close(llm_test_sock);
        llm_test_sock = 0;
        goto llm_error;
    }
    printf("connect success!\n");
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    lines              = R"(
{
    "request_id": "kws_id",
    "work_id": "kws",
    "action": "setup",
    "object": "kws.setup",
    "data": {
        "model": "sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01","response_format": "kws.bool",
        "input": "sys.pcm",
        "enoutput": true,
        "kws": "你好你好"
        }
}

{
    "request_id": "asr_id",
    "work_id": "asr",
    "action": "setup",
    "object": "asr.setup",
    "data": {
        "model": "sherpa-ncnn-streaming-zipformer-zh-14M-2023-02-23",
        "response_format": "asr.utf-8.stream",
        "input": "sys.pcm",
        "enoutput": true,
        "enkws":true,
        "rule1":2.4,
        "rule2":1.2,
        "rule3":30.1
        }
}

{
    "request_id": "llm_id",
    "work_id": "llm",
    "action": "setup","object": "llm.setup",
    "data": {
        "model": "qwen2.5-0.5B-prefill-20e",
        "response_format": "llm.utf-8.stream",
        "input": "llm.utf-8",
        "enoutput": true,
        "max_token_len": 256,
        "prompt": "You are a knowledgeable assistant capable of answering various questions and providing information."
        }
}

{
    "request_id": "melotts_id",
    "work_id": "melotts",
    "action": "setup",
    "object": "melotts.setup",
    "data": {
        "model": "melotts_zh-cn",
        "response_format": "sys.pcm",
        "input": "tts.utf-8",
        "enoutput": false
    }
}
                    )";
    bytes_sent = send(llm_test_sock, lines.c_str(), lines.size(), 0);
    if (bytes_sent == -1) {
        printf("send failed");
        close(llm_test_sock);
        llm_test_sock = 0;
        goto llm_error;
    }
    lines.clear();
    printf("send success!\n");
    ui_lock();
    lv_textarea_add_text(*ui_TextArea, "send success!\n");
    ui_unlock();
    test_success = 0;
    while (charge_flage) {
        struct timeval timeout = {.tv_sec = 20, .tv_usec = 0};
        fd_set set;
        FD_ZERO(&set);
        FD_SET(llm_test_sock, &set);
        int ret = select(llm_test_sock + 1, &set, NULL, NULL, &timeout);
        if (ret == 1) {
            int valread = recv(llm_test_sock, buffer, sizeof(buffer) - 1, 0);
            if (valread == -1) {
                printf("reace failed");
                close(llm_test_sock);
                llm_test_sock = 0;
                goto llm_error;
            }

            lines += std::string(buffer, valread);
            // printf("reace:%.*s\n", valread, buffer);
            while (charge_flage) {
                size_t post = std::string::npos;
                post        = lines.find("\n");
                if (post != std::string::npos) {
                    auto one_data = lines.substr(0, post+1);
                    ui_lock();
                    lv_textarea_add_text(*ui_TextArea, one_data.c_str());
                    ui_unlock();
                    if (one_data.find("asr.1001") != std::string::npos) {
                        test_success += 1;
                    }
                    if (one_data.find("llm.1002") != std::string::npos) {
                        test_success += 1;
                    }
                    if (one_data.find("kws.1000") != std::string::npos) {
                        test_success += 1;
                    }
                    if (one_data.find("melotts.1003") != std::string::npos) {
                        test_success += 1;
                    }
                    lines.erase(0, post + 1);
                    printf("test_success:%d\n", test_success);
                    if (test_success == 4) {
                        ui_lock();
                        lv_textarea_add_text(*ui_TextArea, "init mode success \n");
                        ui_unlock();
                        goto link_start;
                    }
                } else {
                    break;
                }
            }
        } else {
            close(llm_test_sock);
            llm_test_sock         = 0;
            test_success = 0;
            charge_flage = 0;
            goto llm_error;
        }
    }
// }
link_start:
    test_success       = 0;
    lines              = R"(
{
    "request_id": "link_2",
    "work_id": "asr.1001",
    "action": "link",
    "object":"work_id",
    "data":"kws.1000"
}

{
    "request_id": "link_3",
    "work_id": "llm.1002",
    "action": "link",
    "object":"work_id",
    "data":"asr.1001"
}

{
    "request_id": "link_4",
    "work_id": "melotts.1003",
    "action": "link",
    "object":"work_id",
    "data":"llm.1002"
}

{
    "request_id": "link_5",
    "work_id": "llm.1002",
    "action": "link",
    "object":"work_id",
    "data":"kws.1000"
}
{
    "request_id": "link_6",
    "work_id": "melotts.1003",
    "action": "link",
    "object":"work_id",
    "data":"kws.1000"
}
                            )";
    bytes_sent = send(llm_test_sock, lines.c_str(), lines.size(), 0);
    if (bytes_sent == -1) {
        printf("send failed");
        close(llm_test_sock);
        llm_test_sock = 0;
        goto llm_error;
    }
    lines.clear();
    printf("send success!\n");
    while (charge_flage) {
        struct timeval timeout = {.tv_sec = 20, .tv_usec = 0};
        fd_set set;
        FD_ZERO(&set);
        FD_SET(llm_test_sock, &set);
        int ret = select(llm_test_sock + 1, &set, NULL, NULL, &timeout);
        if (ret == 1) {
            int valread = recv(llm_test_sock, buffer, sizeof(buffer) - 1, 0);
            if (valread == -1) {
                printf("reace failed");
                close(llm_test_sock);
                llm_test_sock = 0;
                goto llm_error;
            }
            lines += std::string(buffer, valread);
            // printf("reace:%.*s\n", valread, buffer);
            while (charge_flage) {
                size_t post = std::string::npos;
                post        = lines.find("\n");
                if (post != std::string::npos) {
                    auto one_data = lines.substr(0, post+1);
                    ui_lock();
                    lv_textarea_add_text(*ui_TextArea, one_data.c_str());
                    ui_unlock();
                    if ((one_data.find("link_2") != std::string::npos) &&
                        (one_data.find("\"code\":0") != std::string::npos)) {
                        test_success += 1;
                    }
                    if ((one_data.find("link_3") != std::string::npos) &&
                        (one_data.find("\"code\":0") != std::string::npos)) {
                        test_success += 1;
                    }
                    if ((one_data.find("link_4") != std::string::npos) &&
                        (one_data.find("\"code\":0") != std::string::npos)) {
                        test_success += 1;
                    }
                    if ((one_data.find("link_5") != std::string::npos) &&
                        (one_data.find("\"code\":0") != std::string::npos)) {
                        test_success += 1;
                    }
                    if ((one_data.find("link_6") != std::string::npos) &&
                        (one_data.find("\"code\":0") != std::string::npos)) {
                        test_success += 1;
                    }
                    lines.erase(0, post + 1);
                    if (test_success == 5) {
                        goto reace_msg_start;
                    }
                } else {
                    break;
                }
            }
        } else {
            close(llm_test_sock);
            llm_test_sock         = 0;
            test_success = 0;
            charge_flage = 0;
            goto llm_error;
        }
    }
// }
reace_msg_start:
    lines.clear();
    printf("start reace!\n");
    while (charge_flage) {
        struct timeval timeout = {.tv_sec = 1, .tv_usec = 0};
        fd_set set;
        FD_ZERO(&set);
        FD_SET(llm_test_sock, &set);
        int ret = select(llm_test_sock + 1, &set, NULL, NULL, &timeout);
        if (ret == 1) {
            int valread = recv(llm_test_sock, buffer, sizeof(buffer) - 1, 0);
            if (valread == -1) {
                printf("reace failed");
                close(llm_test_sock);
                llm_test_sock = 0;
                goto llm_error;
            }
            lines += std::string(buffer, valread);
            // printf("reace:%.*s\n", valread, buffer);
            while (charge_flage) {
                size_t post = std::string::npos;
                post        = lines.find("\n");
                if (post != std::string::npos) {
                    auto one_data = lines.substr(0, post+1);
                    ui_lock();
                    lv_textarea_add_text(*ui_TextArea, one_data.c_str());
                    ui_unlock();
                    lines.erase(0, post + 1);
                } else {
                    break;
                }
            }
        }
    }
    // }

    if (llm_test_sock > 0) {
        {
            close(llm_test_sock);
            llm_test_sock = 0;
        }
    }
llm_error:
    printf("reset StackFlow\n");
    system("systemctl restart llm-melotts llm-llm llm-asr llm-kws llm-sys ");
    printf("reset StackFlow success\n");
    ui_lock();
    // if (test_success == 0) {
    //     lv_textarea_add_text(*ui_TextArea, "cam test false!\n");
    //     lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    // } else {
    //     lv_textarea_add_text(*ui_TextArea, "cam test success!\n");
    //     lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF00), LV_PART_MAIN | LV_STATE_DEFAULT);
    // }
    lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_add_text(*ui_TextArea, "LLM over!\n");
    unlock_switch();
    lv_obj_clear_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_add_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    ui_unlock();
}

extern "C"{
    void chagne_page_test(lv_event_t * e);
    void emmc_test(lv_event_t * e);
    void sd_testa(lv_event_t * e);
    void i2c_testa(lv_event_t * e);
    void charge_testa(lv_event_t * e);
    void cmm_testa(lv_event_t * e);
    void wifi_test_call(lv_event_t * e);

    void cap_test_call(lv_event_t * e);
    void play_cap_test_call(lv_event_t * e);
    void play_test_call(lv_event_t * e);
    void sys_load_call(lv_event_t * e);

    void otg_testa(lv_event_t * e);

    void cam_testa(lv_event_t * e);
    void bmi270_testa(lv_event_t * e);

    void llm_test_call(lv_event_t * e);
};
void chagne_page_test(lv_event_t *e)
{
    lv_obj_add_flag(*ui_page, LV_OBJ_FLAG_HIDDEN);
    lv_obj_set_style_bg_color(e->target, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);

    for (size_t i = 0; i < sizeof(map_page_obj) / sizeof(map_page_obj[0]); i++) {
        if (*map_page_obj[i] == *ui_page) {
            lv_obj_set_style_bg_color(*map_btn_obj[i], lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }

    for (size_t i = 0; i < sizeof(map_btn_obj) / sizeof(map_btn_obj[0]); i++) {
        if (*map_btn_obj[i] == e->target) {
            ui_page = map_page_obj[i];
            lv_obj_clear_flag(*ui_page, LV_OBJ_FLAG_HIDDEN);
        }
    }
}

void emmc_test(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button13;
    lv_obj_t ** ui_TextArea = &ui_TextArea1;
    lv_obj_t ** ui_Chart = &ui_Chart1;

    lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    // if (lv_obj_has_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN)) lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN);
    // if (!lv_obj_has_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN)) lv_obj_add_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN);

    // if (ax_llm_connect_flage == 0) {
    //     lv_textarea_add_text(*ui_TextArea, "ax_llm not't connect!\n");
    //     lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    //     return;
    // }
    lock_switch();
    lv_obj_add_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_cmmc_test_task);
    t.detach();
}
void sd_testa(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button14;
    lv_obj_t ** ui_TextArea = &ui_TextArea3;
    lv_obj_t ** ui_Chart = &ui_Chart3;

    lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    // if (lv_obj_has_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN)) lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_HIDDEN);
    // if (!lv_obj_has_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN)) lv_obj_add_flag(*ui_Chart, LV_OBJ_FLAG_HIDDEN);

    // if (ax_llm_connect_flage == 0) {
    //     lv_textarea_add_text(*ui_TextArea, "ax_llm not't connect!\n");
    //     lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
    //     return;
    // }
    lock_switch();
    lv_obj_add_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_sd_test_task);
    t.detach();
}

void i2c_testa(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button16;
    lv_obj_t ** ui_Button1 = &ui_Button25;
    lv_obj_t ** ui_TextArea = &ui_TextArea7;

    lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    lock_switch();
    lv_obj_add_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_add_state(*ui_Button1, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_i2c_test_task);
    t.detach();
}
void bmi270_testa(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button25;
    lv_obj_t ** ui_Button1 = &ui_Button16;
    lv_obj_t ** ui_TextArea = &ui_TextArea7;
    if (charge_flage) {
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
        charge_flage = 0;
    } else {
        charge_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_textarea_set_text(* ui_TextArea, "");
        lv_obj_add_state(*ui_Button1, LV_STATE_DISABLED);
        lock_switch();
        std::thread t(ax_bmi270_test_task);
        t.detach();
    }

    // lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    // lv_textarea_set_text(*ui_TextArea, "");
    // lock_switch();
    // lv_obj_add_state(*ui_Button, LV_STATE_DISABLED);
    // lv_obj_add_state(*ui_Button1, LV_STATE_DISABLED);
    // lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    // std::thread t(ax_bmi270_test_task);
    // t.detach();
}




void charge_testa(lv_event_t *e)
{
    lv_obj_t ** ui_Button = &ui_Button17;
    lv_obj_t ** ui_TextArea = &ui_TextArea6;
    if (charge_flage) {
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
        charge_flage = 0;
    } else {
        charge_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_textarea_set_text(* ui_TextArea, "");

        lock_switch();
        std::thread t(ax_charge_test_task);
        t.detach();
    }
}

void cmm_testa(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button19;
    lv_obj_t ** ui_TextArea = &ui_TextArea10;

    lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    lock_switch();
    lv_obj_add_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_cmm_test_task);
    t.detach();
}

void wifi_test_call(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button20;
    lv_obj_t ** ui_TextArea = &ui_TextArea9;

    lv_obj_set_style_bg_color(*ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    lock_switch();
    lv_obj_add_state(*ui_Button, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_wifi_test_task);
    t.detach();
}



void cap_test_call(lv_event_t * e){
    lv_obj_t **ui_Button1   = &ui_Button21;
    lv_obj_t **ui_Button2   = &ui_Button22;
    lv_obj_t **ui_Button3   = &ui_Button23;
    lv_obj_t **ui_TextArea = &ui_TextArea11;
    if (cap_flage) {
        lv_obj_set_style_bg_color(* ui_Button1, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
        cap_flage = 0;
    } else {
        cap_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button1, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_textarea_set_text(* ui_TextArea, "");
        // lv_obj_add_state(* ui_Button1, LV_STATE_DISABLED);
        lv_obj_add_state(* ui_Button2, LV_STATE_DISABLED);
        lv_obj_add_state(* ui_Button3, LV_STATE_DISABLED);
        lock_switch();
        std::thread t(ax_cap_test_task);
        t.detach();
    }
}
void play_cap_test_call(lv_event_t * e){
    lv_obj_t **ui_Button1   = &ui_Button21;
    lv_obj_t **ui_Button2   = &ui_Button22;
    lv_obj_t **ui_Button3   = &ui_Button23;
    lv_obj_t **ui_TextArea = &ui_TextArea11;

    lv_obj_set_style_bg_color(*ui_Button2, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    lock_switch();
    lv_obj_add_state(* ui_Button1, LV_STATE_DISABLED);
    // lv_obj_add_state(* ui_Button2, LV_STATE_DISABLED);
    lv_obj_add_state(* ui_Button3, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_play_cap_test_task);
    t.detach();
}
void play_test_call(lv_event_t * e){
    lv_obj_t **ui_Button1   = &ui_Button21;
    lv_obj_t **ui_Button2   = &ui_Button22;
    lv_obj_t **ui_Button3   = &ui_Button23;
    lv_obj_t **ui_TextArea = &ui_TextArea11;

    lv_obj_set_style_bg_color(*ui_Button3, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(*ui_TextArea, "");
    lock_switch();
    lv_obj_add_state(* ui_Button1, LV_STATE_DISABLED);
    lv_obj_add_state(* ui_Button2, LV_STATE_DISABLED);
    // lv_obj_add_state(* ui_Button3, LV_STATE_DISABLED);
    lv_obj_clear_flag(*ui_TextArea, LV_OBJ_FLAG_CLICKABLE);
    std::thread t(ax_play_test_test_task);
    t.detach();
}




void sys_load_call(lv_event_t * e){
    lv_obj_t **ui_Button   = &ui_Button24;
    if (cap_flage) {
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x2196f3), LV_PART_MAIN | LV_STATE_DEFAULT);
        cap_flage = 0;
        lv_obj_add_flag(ui_Spinner1, LV_OBJ_FLAG_HIDDEN);
        system("start-stop-daemon --stop --signal INT --pidfile /tmp/.sysbench.pid ");
        system("start-stop-daemon --stop --signal INT --pidfile /tmp/.sample_npu_yolov5s_s.pid ");
        unlock_switch();
    } else {
        cap_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        // "sysbench cpu --time=2592000 --threads=3 run > /dev/null 2>&1 & /opt/bin/sample_npu_yolov5s_s -m "
        // "/opt/data/npu/models/yolov5s.axmodel -i /opt/data/npu/images/cat.jpg -r 2592000 > /dev/null 2>&1 &",
        system("start-stop-daemon --start --quiet --background --pidfile /tmp/.sysbench.pid --make-pidfile --exec /usr/bin/sysbench -- cpu --time=2592000 --threads=3 run");
        system("start-stop-daemon --start --quiet --background --pidfile /tmp/.sample_npu_yolov5s_s.pid --make-pidfile --exec /opt/bin/sample_npu_yolov5s_s -- -m /opt/data/npu/models/yolov5s.axmodel -i /opt/data/npu/images/cat.jpg -r 2592000");
        lv_obj_clear_flag(ui_Spinner1, LV_OBJ_FLAG_HIDDEN);
        lock_switch();
    }
}


void otg_testa(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button15;
    lv_obj_t ** ui_TextArea = &ui_TextArea4;
    lv_obj_t ** ui_TextArea1 = &ui_TextArea5;
    if (charge_flage) {
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
        charge_flage = 0;
    } else {
        charge_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_textarea_set_text(* ui_TextArea, "");
        lv_textarea_set_text(* ui_TextArea1, "");
        lock_switch();
        std::thread t(ax_otg_test_task);
        t.detach();
    }
}

void cam_testa(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button18;
    lv_obj_t ** ui_TextArea = &ui_TextArea8;
    lv_obj_t ** ui_image = &ui_Image2;
    if (charge_flage) {
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
        charge_flage = 0;
    } else {
        charge_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_textarea_set_text(* ui_TextArea, "");
        lock_switch();
        std::thread t(ax_cam_test_task);
        t.detach();
    }
}

void llm_test_call(lv_event_t * e)
{
    lv_obj_t ** ui_Button = &ui_Button27;
    lv_obj_t ** ui_TextArea = &ui_TextArea12;
    if (charge_flage) {
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0x79B4F2), LV_PART_MAIN | LV_STATE_DEFAULT);
        charge_flage = 0;
        if(llm_test_sock)
        {
            close(llm_test_sock);
            llm_test_sock = 0;
        }
    } else {
        charge_flage = 1;
        lv_obj_set_style_bg_color(* ui_Button, lv_color_hex(0xF8BE4E), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_textarea_set_text(* ui_TextArea, "");
        lock_switch();
        std::thread t(ax_llm_test_task);
        t.detach();
    }
}







